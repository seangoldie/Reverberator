# -*- coding: utf-8 -*-
"""Goldie-Reverberator.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uVbSDO5olLTEUcXDCwh_ZEGLENaerc6C
"""

import numpy as np
from IPython.display import Audio
import soundfile as sf
import scipy.signal as sp

'''(Very) Basic Schroeder Reverberator by Sean Goldie
Advanced Musical Acoustics Summer 2021, NYU

Differencing equations (from DSTII lecture notes with Dr. Tae Hong Park, and 
Digital Signal Theory I textbook by Dr. Brian McFee):

Combs: y[n] = x[n] + (damp) * y[n - delay]
Allpasses: y[n] = (attenuation) * x[n] + x[n - delay] - (attenuation) * y[n - delay]

Direct implementation of differencing equations created undesireable results.
Implementation using filter function from Scipy and b/a coefficients follows.

Allpass: y = filter( b = [attenuation, zeros(delay_length), 1], a = [1, zeros(delay_length), attenuation] )
Comb: y = filter ( b = [1, zeros(delay_length - 1), dampening], a = 1)
'''

class CombFilter():
  ''' 
  Processes mono signals only. Arbitrary buffer length for tail.
  Provide delay time and sample rate at instantiation.
  '''

  def __init__(self, delay_in_ms, sample_rate):
    # args: int, int
    self.delay_in_ms = delay_in_ms
    self.delay_in_samples = int(np.ceil(( self.delay_in_ms / 1000 ) * sample_rate))

  def process_buffer(self, x, dampening_coefficient):
    # args: np.array, float
    # b feedback coefficient [1, zero-padding to length of delay - 1, dampening_coefficient]
    # a feedforward coefficient [1, zero-padding to length of b]
    b = [1]
    a = [1]
    for i in range(self.delay_in_samples - 1):
      b.append(0)
      a.append(0)
    b.append(dampening_coefficient)
    a.append(0)
    return sp.lfilter(b, a, x)


class AllPassFilter():
  ''' 
  Processes mono signals only. Arbitrary buffer length for tail.
  Provide delay time and sample rate at instantiation.
  '''
  # b feedback coefficient [1, zero-padding to length of delay - 1, 1]
  # a feedforward coefficient [1, zero-padding to length of delay - 1, attenuation_coefficient]

  def __init__(self, delay_in_ms, sample_rate):
    # args: int, int
    self.delay_in_ms = delay_in_ms
    self.delay_in_samples = int(np.ceil(( self.delay_in_ms / 1000 ) * sample_rate))

  def process_buffer(self, x, attenuation_coefficient):
    # args: np.array, float

    b = [attenuation_coefficient]
    a = [1]

    for i in range(self.delay_in_samples - 1):
      b.append(0)
      a.append(0)

    b.append(1)
    a.append(attenuation_coefficient)


    return sp.lfilter(b, a, x)

class SchroederReverberator():
  ''' 
  Processes mono signals using a signal processing pipeline.
  Args:
  sample_rate: int
  amount: float
  num_combs: int
  comb_dampening: float (counterintuitively, closer to 1 is less dampening)
  num_allpasses: int
  allpass_attenuation: float (same scaling as comb_dampening)
  delay_times: list 
  (must have same number of elements as num_combs + num_allpasses, 
  and be ordered correctly)
  '''
  def __init__(self, 
               sample_rate, 
               amount=0.5, 
               num_combs=4, 
               comb_dampening=0.5, 
               num_allpasses=2, 
               allpass_attenuation=0.5, 
               delay_times=[25, 30, 35, 40, 25, 50]):
    
    self.amount = amount
    self.num_combs = num_combs
    self.num_allpasses = num_allpasses
    self.delay_times = delay_times
    self.processing_pipeline = list()
    self.comb_dampening = comb_dampening
    self.allpass_attenuation = allpass_attenuation

    for i in range(self.num_combs):
      self.processing_pipeline.append( CombFilter(delay_times[i], sample_rate) )

    for i in range(self.num_combs, self.num_combs + self.num_allpasses):
      self.processing_pipeline.append( AllPassFilter(delay_times[i], sample_rate) )

  def process_buffer(self, x):
    # Args: x input signal (np.array)
    length = len(x)
    y = np.zeros(length)
    buffers = list()

    for i in range(self.num_combs):
      buffers.append( self.processing_pipeline[i].process_buffer(x, self.comb_dampening) )

    for j in range(self.num_combs):
      y = np.add(y, (1 / self.num_combs) * buffers[j])
    
    for i in range(self.num_combs, self.num_combs + self.num_allpasses):
      y = self.processing_pipeline[i].process_buffer(y, self.allpass_attenuation)
  
    x_pad = np.zeros( len(y) - len(x) )

    x = np.hstack( (x, x_pad) )

    return np.add(y * self.amount, x * (1 - self.amount))

